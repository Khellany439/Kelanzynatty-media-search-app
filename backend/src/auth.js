/**
 * AUTHENTICATION MODULE
 * PROVIDES USER REGISTRATION AND AUTHENTICATION FUNCTIONALITY USING BCRYPT FOR PASSWORD HASHING
 * AND JSON WEB TOKENS (JWT) FOR SESSION MANAGEMENT. INTEGRATES WITH POSTGRESQL DATABASE FOR
 * USER PERSISTENCE.
 * 
 * KEY FEATURES:
 * - SECURE PASSWORD STORAGE WITH BCRYPT SALTING AND HASHING
 * - JWT-BASED STATELESS AUTHENTICATION
 * - DATABASE-INTEGRATED USER MANAGEMENT
 * - ERROR-HANDLED OPERATIONS WITH APPROPRIATE HTTP STATUS CODES
 * 
 * DEPENDENCIES:
 * - BCRYPTJS: PASSWORD HASHING LIBRARY
 * - JSONWEBTOKEN: JWT IMPLEMENTATION FOR TOKEN GENERATION
 * - DB: DATABASE CONNECTION MODULE
 * 
 * AUTHOR: Kelanzy
 * DATE: 2025-5-3
 * VERSION: 1.0.0
 * REQUIREMENTS:
 * - JWT_SECRET ENVIRONMENT VARIABLE SET
 * - USERS TABLE WITH USERNAME AND PASSWORD COLUMNS
 */

const bcrypt = require('bcryptjs'); // IMPORT PASSWORD HASHING LIBRARY (SALT ROUNDS: 10)
const jwt = require('jsonwebtoken'); // IMPORT JWT IMPLEMENTATION FOR TOKEN GENERATION
const db = require('./db'); // IMPORT DATABASE CONNECTION POOL

/**
 * USER REGISTRATION HANDLER
 * CREATES NEW USER WITH HASHED PASSWORD STORAGE. VALIDATES UNIQUE USERNAME THROUGH DATABASE CONSTRAINTS.
 * 
 * PARAMETERS:
 * @param {express.Request} req - EXPRESS REQUEST OBJECT CONTAINING {username, password} IN BODY
 * @param {express.Response} res - EXPRESS RESPONSE OBJECT FOR SENDING RESPONSES
 * 
 * RESPONSE:
 * - 201 CREATED: SUCCESSFUL REGISTRATION WITH USER DATA
 * - 500 INTERNAL SERVER ERROR: DATABASE OPERATION FAILURE
 * 
 * SECURITY NOTES:
 * - USES BCRYPT HASHING WITH COST FACTOR 10
 * - NEVER STORES PLAINTEXT PASSWORDS
 * - REQUIRES UNIQUE USERNAME CONSTRAINT IN DATABASE
 * 
 * EXAMPLE USAGE:
 * POST /api/auth/register
 * BODY: { "username": "user@example.com", "password": "SecurePass123!" }
 */
const registerUser = async (req, res) => {
    const { username, password } = req.body; // EXTRACT CREDENTIALS FROM REQUEST BODY

    try {
        // HASH PASSWORD WITH BCRYPT USING 10 SALT ROUNDS (BALANCE BETWEEN SECURITY AND PERFORMANCE)
        const hashedPassword = await bcrypt.hash(password, 10);

        // INSERT USER INTO DATABASE USING PARAMETERIZED QUERY TO PREVENT SQL INJECTION
        const result = await db.query(
            'INSERT INTO users (username, password) VALUES ($1, $2) RETURNING *',
            [username, hashedPassword]
        );

        // RETURN 201 CREATED STATUS WITH USER DATA (EXCLUDING PASSWORD HASH)
        res.status(201).json(result.rows[0]);

    } catch (error) {
        // HANDLE UNIQUE CONSTRAINT VIOLATION SEPARATELY FOR BETTER ERROR MESSAGES
        if (error.code === '23505') {
            return res.status(409).json({ error: 'USERNAME ALREADY EXISTS' });
        }
        // GENERIC ERROR RESPONSE TO AVOID LEAKING SENSITIVE INFORMATION
        res.status(500).json({ error: 'USER REGISTRATION FAILED' });
    }
};

/**
 * USER AUTHENTICATION HANDLER
 * VERIFIES USER CREDENTIALS AND ISSUES JWT TOKEN FOR SUBSEQUENT REQUESTS.
 * 
 * PARAMETERS:
 * @param {express.Request} req - EXPRESS REQUEST OBJECT CONTAINING {username, password} IN BODY
 * @param {express.Response} res - EXPRESS RESPONSE OBJECT FOR SENDING RESPONSES
 * 
 * RESPONSE:
 * - 200 OK: SUCCESSFUL LOGIN WITH JWT TOKEN
 * - 401 UNAUTHORIZED: INVALID CREDENTIALS
 * - 500 INTERNAL SERVER ERROR: AUTHENTICATION FAILURE
 * 
 * SECURITY NOTES:
 * - USES TIMING-SAFE BCRYPT COMPARE FUNCTION
 * - TOKENS SIGNED WITH HMAC SHA-256 ALGORITHM
 * - TOKENS MUST BE STORED SECURELY ON CLIENT-SIDE
 * 
 * EXAMPLE USAGE:
 * POST /api/auth/login
 * BODY: { "username": "user@example.com", "password": "SecurePass123!" }
 */
const loginUser = async (req, res) => {
    const { username, password } = req.body; // EXTRACT LOGIN CREDENTIALS

    try {
        // FETCH USER FROM DATABASE USING PARAMETERIZED QUERY
        const result = await db.query('SELECT * FROM users WHERE username = $1', [username]);

        // USER NOT FOUND RESPONSE (GENERIC MESSAGE FOR SECURITY)
        if (result.rows.length === 0) {
            return res.status(401).json({ error: 'INVALID CREDENTIALS' });
        }

        const user = result.rows[0]; // EXTRACT USER RECORD

        // SECURE PASSWORD COMPARISON WITH BCRYPT (TIMING ATTACK PROTECTION)
        const isPasswordValid = await bcrypt.compare(password, user.password);

        // INVALID PASSWORD RESPONSE (GENERIC MESSAGE)
        if (!isPasswordValid) {
            return res.status(401).json({ error: 'INVALID CREDENTIALS' });
        }

        // GENERATE JWT TOKEN WITH USER ID PAYLOAD
        const token = jwt.sign(
            { id: user.id }, // TOKEN PAYLOAD (AVOID SENSITIVE DATA)
            process.env.JWT_SECRET, // SECRET KEY FROM ENVIRONMENT VARIABLES
            { expiresIn: '1h' } // TOKEN EXPIRATION (RECOMMENDED FOR SECURITY)
        );

        // RETURN TOKEN IN STANDARD JSON RESPONSE
        res.json({ token });

    } catch (error) {
        // GENERIC ERROR RESPONSE
        res.status(500).json({ error: 'LOGIN FAILED' });
    }
};

/**
 * MODULE EXPORTS
 * EXPOSES AUTHENTICATION FUNCTIONS FOR ROUTE INTEGRATION
 * @exports {Object} AUTHENTICATION FUNCTIONS
 */
module.exports = {
    registerUser,
    loginUser,
};

/**
 * SECURITY CONSIDERATIONS:
 * 1. JWT SECRET MUST BE STRONG AND PROTECTED (MIN 64 CHAR HEX)
 * 2. IMPLEMENT REFRESH TOKEN STRATEGY FOR LONG-LIVED SESSIONS
 * 3. USE HTTPS IN PRODUCTION TO PROTECT CREDENTIALS IN TRANSIT
 * 4. CONSIDER IMPLEMENTING RATE LIMITING ON AUTH ENDPOINTS
 * 5. PASSWORD COMPLEXITY REQUIREMENTS SHOULD BE ENFORCED CLIENT-SIDE
 * 
 * IMPROVEMENT OPPORTUNITIES:
 * - ADD EMAIL VERIFICATION WORKFLOW
 * - IMPLEMENT PASSWORD RESET FUNCTIONALITY
 * - ADD AUDIT LOGGING FOR AUTH EVENTS
 * - INCLUDE USER ROLES IN TOKEN PAYLOAD
 * - IMPLEMENT TOKEN BLACKLIST FOR LOGOUT FUNCTIONALITY
 */

/**
 * ERROR HANDLING ENHANCEMENT NOTES:
 * 1. USE CUSTOM ERROR CLASSES FOR BETTER ERROR CATEGORIZATION
 * 2. IMPLEMENT CENTRALIZED ERROR HANDLING MIDDLEWARE
 * 3. ADD REQUEST VALIDATION FOR CREDENTIAL FORMATS
 * 4. MASK SENSITIVE DATA IN ERROR RESPONSES
 * 
 * EXAMPLE VALIDATION MIDDLEWARE:
 * const validateCredentials = (req, res, next) => {
 *     if (!req.body.username || !req.body.password) {
 *         return res.status(400).json({ error: 'MISSING CREDENTIALS' });
 *     }
 *     next();
 * };
 */
