/**
 * JWT AUTHENTICATION MIDDLEWARE MODULE
 * PROVIDES SECURE TOKEN VERIFICATION FOR PROTECTED ROUTES.
 * IMPLEMENTS BEARER TOKEN VALIDATION AND USER CONTEXT ATTACHMENT.
 * 
 * KEY FEATURES:
 * - EXTRACTS AND VALIDATES JWT FROM AUTHORIZATION HEADER
 * - ATTACHES DECODED USER PAYLOAD TO REQUEST OBJECT
 * - HANDLES TOKEN EXPIRATION AND INVALID SIGNATURE ERRORS
 * - INTEGRATES WITH ENVIRONMENT-BASED SECRET MANAGEMENT
 * 
 * AUTHOR: KELANZY
 * DATE: 2023-10-23
 * VERSION: 1.0.0
 * REQUIREMENTS:
 * - JWT_SECRET ENVIRONMENT VARIABLE SET
 * - BEARER TOKEN IN AUTHORIZATION HEADER
 */

const jwt = require('jsonwebtoken');
require('dotenv').config(); // LOAD ENVIRONMENT VARIABLES

/**
 * AUTHENTICATION MIDDLEWARE FUNCTION
 * VERIFIES JWT TOKEN AND ATTACHES USER CONTEXT TO REQUEST
 * 
 * @param {Object} req - EXPRESS REQUEST OBJECT
 * @param {Object} res - EXPRESS RESPONSE OBJECT
 * @param {Function} next - EXPRESS NEXT MIDDLEWARE FUNCTION
 * 
 * BEHAVIOR:
 * 1. CHECKS FOR BEARER TOKEN IN AUTHORIZATION HEADER
 * 2. VERIFIES TOKEN SIGNATURE AND EXPIRATION
 * 3. ATTACHES DECODED PAYLOAD TO REQUEST.USER
 * 4. HANDLES INVALID/EXPIRED TOKEN SCENARIOS
 * 
 * SECURITY NOTES:
 * - REQUIRES HTTPS IN PRODUCTION ENVIRONMENTS
 * - TOKENS MUST BE STORED SECURELY ON CLIENT-SIDE
 * - SECRET KEYS MUST BE 64+ CHARACTERS LONG
 */
const authMiddleware = (req, res, next) => {
    // EXTRACT AUTHORIZATION HEADER FROM REQUEST
    const authHeader = req.headers.authorization;

    // VALIDATE HEADER FORMAT AND PRESENCE
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ 
            message: 'UNAUTHORIZED: NO TOKEN PROVIDED' 
        });
    }

    // EXTRACT TOKEN FROM HEADER STRING
    const token = authHeader.split(' ')[1];

    try {
        // VERIFY TOKEN SIGNATURE AND DECODE PAYLOAD
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // ATTACH DECODED USER DATA TO REQUEST OBJECT
        req.user = decoded;
        
        // PROCEED TO PROTECTED ROUTE
        next();
    } catch (error) {
        // HANDLE SPECIFIC JWT ERRORS
        const errorMessage = error.name === 'TokenExpiredError' 
            ? 'EXPIRED TOKEN' 
            : 'INVALID TOKEN';
            
        return res.status(401).json({ 
            message: `UNAUTHORIZED: ${errorMessage}` 
        });
    }
};

/**
 * MODULE EXPORTS
 * @exports {function} authMiddleware - JWT VERIFICATION MIDDLEWARE
 */
module.exports = authMiddleware;

/**
 * ERROR HANDLING STRATEGY:
 * - SPECIFIC ERROR MESSAGES FOR EXPIRED VS INVALID TOKENS
 * - CONSISTENT 401 UNAUTHORIZED RESPONSE FORMAT
 * - NO SENSITIVE INFORMATION LEAKED IN ERRORS
 * 
 * USAGE EXAMPLE:
 * router.get('/protected-route', authMiddleware, (req, res) => {
 *     // ACCESS USER DATA VIA req.user
 *     res.json({ user: req.user });
 * });
 */

/**
 * SECURITY CONSIDERATIONS:
 * 1. IMPLEMENT TOKEN BLACKLIST FOR LOGOUT FUNCTIONALITY
 * 2. CONSIDER SHORT TOKEN EXPIRATION TIMES (15-30 MINUTES)
 * 3. USE REFRESH TOKENS FOR LONG-LIVED SESSIONS
 * 4. MONITOR FAILED AUTHENTICATION ATTEMPTS
 * 
 * PERFORMANCE NOTES:
 * - JWT VERIFICATION IS SYNCHRONOUS - CONSIDER ASYNC IMPLEMENTATION
 * - CACHE PUBLIC KEYS IF USING RS256 ALGORITHM
 * - AVOID LARGE PAYLOADS IN JWT TOKENS
 */

/**
 * RELATED MODULES:
 * - authController.js: TOKEN GENERATION LOGIC
 * - errorHandler.js: CENTRAL ERROR PROCESSING
 * - userModel.js: USER DATA STRUCTURE
 * - rateLimiter.js: BRUTE FORCE PROTECTION
 */
